// Generated by CoffeeScript 1.7.1
(function() {
  var animate, camera, clock, container, controls, generateHeight, generateTexture, init, mesh, render, renderer, scene, texture, worldDepth, worldHalfDepth, worldHalfWidth, worldWidth;

  container = null;

  camera = null;

  controls = null;

  scene = null;

  renderer = null;

  mesh = null;

  texture = null;

  worldWidth = 256;

  worldDepth = 256;

  worldHalfWidth = worldWidth / 2;

  worldHalfDepth = worldDepth / 2;

  clock = new THREE.Clock();

  init = function() {
    var data, geometry, i, vertices, _i, _ref;
    container = document.getElementById('container');
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
    scene = new THREE.Scene();
    controls = new THREE.FirstPersonControls(camera);
    controls.movementSpeed = 1000;
    controls.lookSpeed = 0.1;
    data = generateHeight(worldWidth, worldDepth);
    camera.position.y = data[worldHalfWidth + worldHalfDepth * worldWidth] * 10 + 500;
    geometry = new THREE.PlaneBufferGeometry(7500, 7500, worldWidth - 1, worldDepth - 1);
    geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
    vertices = geometry.attributes.position.array;
    for (i = _i = 0, _ref = vertices.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      vertices[3 * i + 1] = data[i] * 10;
    }
    texture = new THREE.Texture(generateTexture(data, worldWidth, worldDepth), THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping);
    texture.needsUpdate = true;
    mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
      map: texture
    }));
    scene.add(mesh);
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0xbfd1e5);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    return container.appendChild(renderer.domElement);
  };

  generateHeight = function(width, height) {
    var data, i, j, perlin, quality, size, x, y, z, _i, _j;
    size = width * height;
    data = new Uint8Array(size);
    perlin = new ImprovedNoise();
    quality = 1;
    z = Math.random() * 100;
    for (j = _i = 0; _i < 4; j = ++_i) {
      for (i = _j = 0; 0 <= size ? _j < size : _j > size; i = 0 <= size ? ++_j : --_j) {
        x = i % width;
        y = ~~(i / width);
        data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);
      }
      quality *= 5;
    }
    return data;
  };

  generateTexture = function(data, width, height) {
    var canvas, canvasScaled, context, diff, i, image, imageData, j, level, shade, sun, v, vector3, _i, _j, _ref, _ref1, _ref2, _ref3;
    _ref = [null, null, null, null, null], canvas = _ref[0], canvasScaled = _ref[1], context = _ref[2], image = _ref[3], imageData = _ref[4];
    _ref1 = [null, null, null, null], level = _ref1[0], diff = _ref1[1], vector3 = _ref1[2], sun = _ref1[3], shade = _ref1[4];
    vector3 = new THREE.Vector3(0, 0, 0);
    sun = new THREE.Vector3(1, 1, 1);
    sun.normalize();
    canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    context = canvas.getContext('2d');
    context.fillStyle = '#000';
    context.fillRect(0, 0, width, height);
    image = context.getImageData(0, 0, canvas.width, canvas.height);
    imageData = image.data;
    for (i = _i = 0, _ref2 = imageData.length; _i < _ref2; i = _i += 4) {
      j = i / 4;
      vector3.x = data[j - 2] - data[j + 2];
      vector3.y = 2;
      vector3.z = data[j - width * 2] - data[j + width * 2];
      vector3.normalize();
      shade = vector3.dot(sun);
      imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
      imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
      imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);
    }
    context.putImageData(image, 0, 0);
    canvasScaled = document.createElement('canvas');
    canvasScaled.width = width * 4;
    canvasScaled.height = height * 4;
    context = canvasScaled.getContext('2d');
    context.scale(4, 4);
    context.drawImage(canvas, 0, 0);
    image = context.getImageData(0, 0, canvasScaled.width, canvasScaled.height);
    imageData = image.data;
    for (i = _j = 0, _ref3 = imageData.length; _j < _ref3; i = _j += 4) {
      v = ~~(Math.random() * 5);
      imageData[i] += v;
      imageData[i + 1] += v;
      imageData[i + 2] += v;
    }
    context.putImageData(image, 0, 0);
    return canvasScaled;
  };

  animate = function() {
    requestAnimationFrame(animate);
    return render();
  };

  render = function() {
    controls.update(clock.getDelta());
    return renderer.render(scene, camera);
  };

  init();

  animate();

}).call(this);
