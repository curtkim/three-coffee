// Generated by CoffeeScript 1.7.1
(function() {
  var HEIGHT, WIDTH, animate, camera, container, geometry, init, particleSystem, particles, render, renderer, scene, uniforms;

  container = null;

  camera = null;

  scene = null;

  renderer = null;

  particleSystem = null;

  uniforms = null;

  geometry = null;

  particles = 100000;

  WIDTH = window.innerWidth;

  HEIGHT = window.innerHeight;

  init = function() {
    var attributes, color, positions, radius, shaderMaterial, v, values_color, values_size, _i;
    camera = new THREE.PerspectiveCamera(40, WIDTH / HEIGHT, 1, 10000);
    camera.position.z = 300;
    scene = new THREE.Scene();
    attributes = {
      size: {
        type: 'f',
        value: null
      },
      customColor: {
        type: 'c',
        value: null
      }
    };
    uniforms = {
      color: {
        type: "c",
        value: new THREE.Color(0xffffff)
      },
      texture: {
        type: "t",
        value: THREE.ImageUtils.loadTexture("../examples/textures/sprites/spark1.png")
      }
    };
    shaderMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      attributes: attributes,
      vertexShader: 'attribute float size;\nattribute vec3 customColor;\nvarying vec3 vColor;\nvoid main() {\n  vColor = customColor;\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_PointSize = size * ( 200.0 / length( mvPosition.xyz ) );\n  gl_Position = projectionMatrix * mvPosition;\n}',
      fragmentShader: 'uniform vec3 color;\nuniform sampler2D texture;\nvarying vec3 vColor;\nvoid main() {\n  gl_FragColor = vec4( color * vColor, 1.0 );\n  gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );\n}',
      blending: THREE.AdditiveBlending,
      depthTest: false,
      transparent: true
    });
    radius = 200;
    geometry = new THREE.BufferGeometry();
    positions = new Float32Array(particles * 3);
    values_color = new Float32Array(particles * 3);
    values_size = new Float32Array(particles);
    color = new THREE.Color();
    for (v = _i = 0; 0 <= particles ? _i < particles : _i > particles; v = 0 <= particles ? ++_i : --_i) {
      values_size[v] = 20;
      positions[v * 3 + 0] = (Math.random() * 2 - 1) * radius;
      positions[v * 3 + 1] = (Math.random() * 2 - 1) * radius;
      positions[v * 3 + 2] = (Math.random() * 2 - 1) * radius;
      color.setHSL(v / particles, 1.0, 0.5);
      values_color[v * 3 + 0] = color.r;
      values_color[v * 3 + 1] = color.g;
      values_color[v * 3 + 2] = color.b;
    }
    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.addAttribute('customColor', new THREE.BufferAttribute(values_color, 3));
    geometry.addAttribute('size', new THREE.BufferAttribute(values_size, 1));
    particleSystem = new THREE.PointCloud(geometry, shaderMaterial);
    scene.add(particleSystem);
    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(WIDTH, HEIGHT);
    container = document.getElementById('container');
    return container.appendChild(renderer.domElement);
  };

  animate = function() {
    requestAnimationFrame(animate);
    return render();
  };

  render = function() {
    var i, size, time, _i;
    time = Date.now() * 0.005;
    particleSystem.rotation.z = 0.01 * time;
    size = geometry.attributes.size.array;
    for (i = _i = 0; 0 <= particles ? _i < particles : _i > particles; i = 0 <= particles ? ++_i : --_i) {
      size[i] = 10 * (1 + Math.sin(0.1 * i + time));
    }
    geometry.attributes.size.needsUpdate = true;
    return renderer.render(scene, camera);
  };

  init();

  animate();

}).call(this);
