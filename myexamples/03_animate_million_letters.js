// Generated by CoffeeScript 1.7.1
(function() {
  var animate, book, camera, fontSize, geo, lettersPerSide, makeBookGeometry, makeTexture, mat, renderer, scene, shaderMaterial, tex, uniforms;

  fontSize = 16;

  lettersPerSide = 16;

  scene = new THREE.Scene();

  makeTexture = function() {
    var c, ctx, tex, x, y, _i, _j;
    c = document.createElement('canvas');
    c.width = c.height = fontSize * lettersPerSide;
    ctx = c.getContext('2d');
    ctx.font = fontSize + 'px Monospace';
    for (y = _i = 0; 0 <= lettersPerSide ? _i < lettersPerSide : _i > lettersPerSide; y = 0 <= lettersPerSide ? ++_i : --_i) {
      for (x = _j = 0; 0 <= lettersPerSide ? _j < lettersPerSide : _j > lettersPerSide; x = 0 <= lettersPerSide ? ++_j : --_j) {
        ctx.fillText(String.fromCharCode(lettersPerSide * y + x), x * fontSize, -(8 / 32) * fontSize + (y + 1) * fontSize);
      }
    }
    tex = new THREE.Texture(c);
    tex.flipY = false;
    tex.needsUpdate = true;
    return tex;
  };

  makeBookGeometry = function(str) {
    var Off, ch, code, cx, cy, geo, i, j, ln, ox, oy, sz, _i, _len;
    geo = new THREE.Geometry();
    j = 0;
    ln = 0;
    for (i = _i = 0, _len = str.length; _i < _len; i = ++_i) {
      ch = str[i];
      code = str.charCodeAt(i);
      cx = code % lettersPerSide;
      cy = Math.floor(code / lettersPerSide);
      geo.vertices.push(new THREE.Vector3(j * 1.1 + 0.05, ln * 1.1 + 0.05, 0), new THREE.Vector3(j * 1.1 + 1.05, ln * 1.1 + 0.05, 0), new THREE.Vector3(j * 1.1 + 1.05, ln * 1.1 + 1.05, 0), new THREE.Vector3(j * 1.1 + 0.05, ln * 1.1 + 1.05, 0));
      geo.faces.push(new THREE.Face3(i * 4 + 0, i * 4 + 1, i * 4 + 2));
      geo.faces.push(new THREE.Face3(i * 4 + 0, i * 4 + 2, i * 4 + 3));
      ox = (cx + 0.05) / lettersPerSide;
      oy = (cy + 0.05) / lettersPerSide;
      Off = 0.9 / lettersPerSide;
      sz = lettersPerSide * fontSize;
      geo.faceVertexUvs[0].push([new THREE.Vector2(ox, oy + Off), new THREE.Vector2(ox + Off, oy + Off), new THREE.Vector2(ox + Off, oy)]);
      geo.faceVertexUvs[0].push([new THREE.Vector2(ox, oy + Off), new THREE.Vector2(ox + Off, oy), new THREE.Vector2(ox, oy)]);
      if (code === 10) {
        ln--;
        j = 0;
      } else {
        j++;
      }
    }
    return geo;
  };

  geo = makeBookGeometry('The Project Gutenberg EBook of Metamorphosis, by Franz Kafka\nTranslated by David Wyllie.');

  tex = makeTexture();

  uniforms = {
    time: {
      type: "f",
      value: 1.0
    },
    size: {
      type: "v2",
      value: new THREE.Vector2(window.innerWidth, window.innerHeight)
    },
    map: {
      type: "t",
      value: tex
    },
    effectAmount: {
      type: "f",
      value: 0.0
    }
  };

  shaderMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: 'varying float vZ;\nuniform float time;\nuniform float effectAmount;\nvarying vec2 vUv;\n\nmat3 rotateAngleAxisMatrix(float angle, vec3 axis) {\n  float c = cos(angle);\n  float s = sin(angle);\n  float t = 1.0 - c;\n  axis = normalize(axis);\n  float x = axis.x, y = axis.y, z = axis.z;\n  return mat3(\n    t*x*x + c,    t*x*y + s*z,  t*x*z - s*y,\n    t*x*y - s*z,  t*y*y + c,    t*y*z + s*x,\n    t*x*z + s*y,  t*y*z - s*x,  t*z*z + c\n  );\n}\n\nvec3 rotateAngleAxis(float angle, vec3 axis, vec3 v) {\n  return rotateAngleAxisMatrix(angle, axis) * v;\n}\n\nvoid main() {\n  float idx = floor(position.y/1.1)*80.0 + floor(position.x/1.1);\n  vec3 corner = vec3(floor(position.x/1.1)*1.1, floor(position.y/1.1)*1.1, 0.0);\n  vec3 mid = corner + vec3(0.5, 0.5, 0.0);\n  vec3 rpos = rotateAngleAxis(idx+time, vec3(mod(idx,16.0), -8.0+mod(idx,15.0), 1.0), position - mid) + mid;\n  vec4 fpos = vec4( mix(position,rpos,effectAmount), 1.0 );\n  fpos.x += -35.0;\n  fpos.z += ((sin(idx+time*2.0)))*4.2*effectAmount;\n  fpos.y += ((cos(idx+time*2.0)))*4.2*effectAmount;\n  vec4 mvPosition = modelViewMatrix * fpos;\n  mvPosition.y += 10.0*sin(time*0.5+mvPosition.x/25.0)*effectAmount;\n  mvPosition.x -= 10.0*cos(time*0.5+mvPosition.y/25.0)*effectAmount;\n  vec4 p = projectionMatrix * mvPosition;\n  vUv = uv;\n  vZ = p.z;\n  gl_Position = p;\n  /*\n  vec4 p = projectionMatrix * modelViewMatrix * vec4 (position, 1.0);\n  vUv = uv;\n  vZ = p.z;\n  gl_Position = p;\n  */\n}',
    fragmentShader: 'varying float vZ;\nvarying vec2 vUv;\nuniform float time;\nuniform float effectAmount;\nuniform vec2 size;\nuniform sampler2D map;\nvoid main() {\n  vec2 d = gl_FragCoord.xy - (0.5+0.02*sin(time))*size*vec2(1.0, 1.0);\n  vec4 diffuse = texture2D(map, vUv);\n  float a = sin(time*0.3)*2.0*3.14159;\n  d = vec2( d.x*cos(a) + d.y*sin(a), -d.x*sin(a) + d.y*cos(a));\n  vec2 rg = vec2(0.0)+abs(d)/(0.5*size);\n  float b = abs(vZ) / 540.0;\n  gl_FragColor = mix(diffuse, vec4(rg,b,diffuse.a), 0.5);\n}'
  });

  shaderMaterial.transparent = true;

  shaderMaterial.depthTest = false;

  mat = new THREE.MeshBasicMaterial({
    map: tex
  });

  mat.transparent = true;

  book = new THREE.Mesh(geo, shaderMaterial);

  scene.add(book);

  camera = new THREE.PerspectiveCamera(45, 1, 4, 40000);

  camera.position.z = 40;

  camera.lookAt(scene.position);

  scene.add(camera);

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });

  renderer.setClearColor(0xffffff);

  document.body.appendChild(renderer.domElement);

  window.onresize = function() {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    return camera.updateProjectionMatrix();
  };

  window.onresize();

  animate = function() {
    uniforms.time.value += 0.01;
    uniforms.effectAmount.value = 0.1;
    renderer.render(scene, camera);
    return requestAnimationFrame(animate, renderer.domElement);
  };

  animate();

}).call(this);
